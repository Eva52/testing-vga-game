
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE1_SOC_Bluetooth_Slave(

	//////////// CLOCK //////////
	input 		          		CLOCK_50,

	//////////// RESET //////////
	input 		          		RESET, // reset low

	//////////// KEY_out //////////
	output			[4:0]		KEY_out,

	output						reset_out,

	//////////// SW //////////
	input 		     [3:0]		SW,

	//////////// GPIO_0, GPIO connect to RFS - RF and Sensor //////////
	inout 		     [35:0]		GPIO_0
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire 				rts; // request to send		  
wire 				cts; // clear to send
wire 				rxd;
wire 				txd;
wire	 [7:0]   uart_data;
wire	         rdempty;
wire	         write;
reg	     	   read;
reg	         cnt;

wire BT_UART_RX = GPIO_0[18];
wire BT_UART_TX = GPIO_0[19];
wire BT_KEY = GPIO_0[8];

assign KEY_out[3:0] = state[3:0];
assign reset_out = state[4];

//=======================================================
//  Structural coding
//=======================================================

// UART Controller
uart_control UART0(

	.clk(CLOCK_50),
	.reset_n(RESET),
	// tx
	.write(write),
	.writedata(uart_data),

	// rx
	.read(read),
	.readdata(uart_data),
	.rdempty(rdempty),
	//
	.uart_clk_25m(cnt),
	.uart_tx(BT_UART_TX),
	.uart_rx(BT_UART_RX)
	
);	

//read
always@(posedge CLOCK_50)
begin
  if (~rdempty)
		read <= 1;
  else
		read <= 0;
end
assign  write = ( read & (~rdempty) );

reg [9:0] state;
reg [4:0] action;
reg [1:0] count;

parameter pulse_00 		= 5'b00001;
parameter pulse_01 		= 5'b00010;
parameter pulse_10 		= 5'b00011;
parameter pulse_11 		= 5'b00100;
parameter pulse_20 		= 5'b00101;
parameter pulse_21 		= 5'b00110;
parameter pulse_30 		= 5'b00111;
parameter pulse_31 		= 5'b01000;
parameter pulse_reset0 	= 5'b01001;
parameter pulse_reset1 	= 5'b01010;

parameter idle		= 10'b00000_00000;
parameter send_00 	= 10'b00001_00001;
parameter send_01 	= 10'b10001_00001;
parameter send_10 	= 10'b00010_00010;
parameter send_11 	= 10'b10010_00010;
parameter send_20 	= 10'b00011_00100;
parameter send_21 	= 10'b10011_00100;
parameter send_30 	= 10'b00100_01000;
parameter send_31 	= 10'b10100_01000;
parameter send_r0 	= 10'b00101_10000;
parameter send_r1 	= 10'b10101_10000;
parameter wait_00 	= 10'b00110_00000;
parameter wait_01 	= 10'b10110_00000;
parameter wait_10 	= 10'b00111_00000;
parameter wait_11 	= 10'b10111_00000;
parameter wait_20 	= 10'b01000_00000;
parameter wait_21 	= 10'b11000_00000;
parameter wait_30 	= 10'b01001_00000;
parameter wait_31 	= 10'b11001_00000;
parameter wait_r0 	= 10'b01010_00000;
parameter wait_r1 	= 10'b11010_00000;

always@(posedge CLOCK_50 or negedge RESET)
begin
	if(!RESET)
		action <= 0;
	else if(RESET & write)
	begin
		case(uart_data)
		10'h30:	action <= pulse_00;
		10'h34: action <= pulse_01;
		10'h31: action <= pulse_10;
		10'h35: action <= pulse_11;
		10'h32: action <= pulse_20;
		10'h36: action <= pulse_21;
		10'h33: action <= pulse_30;
		10'h37: action <= pulse_31;
		10'h38: action <= pulse_reset0;
		10'h39: action <= pulse_reset1;
		default : action <= action;
		endcase
	end
	else
		action <= action;
end

always@(posedge CLOCK_50 or negedge RESET)
begin
	if(!RESET)
		state <= 0;
	else 
	begin
		case(state)
		idle: begin
			case(action)
				pulse_00: state <= send_00;
				pulse_01: state <= send_01;
				pulse_10: state <= send_10;
				pulse_11: state <= send_11;
				pulse_20: state <= send_20;
				pulse_21: state <= send_21;
				pulse_30: state <= send_30;
				pulse_31: state <= send_31;
				pulse_reset0: state <= send_r0;
				pulse_reset1: state <= send_r1;
			endcase
		end

		send_00: if (count == 3) state <= wait_00;
		send_01: if (count == 3) state <= wait_01;

		send_10: if (count == 3) state <= wait_10;
		send_11: if (count == 3) state <= wait_11;

		send_20: if (count == 3) state <= wait_20;
		send_21: if (count == 3) state <= wait_21;

		send_30: if (count == 3) state <= wait_30;
		send_31: if (count == 3) state <= wait_31;

		send_r0: if (count == 3) state <= wait_r0;
		send_r1: if (count == 3) state <= wait_r1;

		wait_00: if(action !== pulse_00) state <= idle;
		wait_01: if(action !== pulse_01) state <= idle;
		wait_10: if(action !== pulse_10) state <= idle;
		wait_11: if(action !== pulse_11) state <= idle;
		wait_20: if(action !== pulse_20) state <= idle;
		wait_21: if(action !== pulse_21) state <= idle;
		wait_30: if(action !== pulse_30) state <= idle;
		wait_31: if(action !== pulse_31) state <= idle;
		wait_r0: if(action !== pulse_reset0) state <= idle;
		wait_r1: if(action !== pulse_reset1) state <= idle;

		default : state <= idle;
		endcase
	end

end


always@(posedge CLOCK_50)
begin
	cnt <= cnt + 1;
	if(!RESET)
		count <= 0;
	else  if (state == idle)
		count <= 0;
	else
		count <= count + 1;
end


endmodule
